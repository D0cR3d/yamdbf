{"version":3,"sources":["command/resolvers/Resolver.ts"],"names":[],"mappings":";;AAIA;;;;;;;;;;GAUG;AACH;IAOC,YAAmB,MAAc,EAAE,IAAY,EAAE,GAAG,OAAiB;QAEpE,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB;;;WAGG;QACH,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QAEjB;;;WAGG;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACxB,CAAC;IAED;;;;;;OAMG;IACI,QAAQ,CAAC,KAAU;QAEzB,MAAM,IAAI,KAAK,CAAC,gDAAgD,CAAC,CAAC;IACnE,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACI,OAAO,CAAC,OAAgB,EAAE,OAAgB,EAAE,IAAY,EAAE,KAAa;QAE7E,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;IAClE,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BG;IACI,UAAU,CAAC,KAAa,EAAE,OAA0B,IAAQ,CAAC;CACpE;AA3FD,4BA2FC","file":"Resolver.js","sourcesContent":["import { Client } from '../../client/Client';\nimport { Message } from '../../types/Message';\nimport { Command } from '../Command';\n\n/**\n * Resolver class to extend for creating Command argument resolvers.\n * Custom Resolvers must implement the `validate()` and `resolve()` methods\n * @param {Client} client YAMDBF Client instance\n * @param {string} name Resolver type name. This is the type name used\n * \t\t\t\t\t\twhen specifying types in [resolve]{@link module:Middleware.resolve}\n * \t\t\t\t\t\tand [expect]{@link module:Middleware.expect}<br>\n * \t\t\t\t\t\t**Note:** This is not passed by the ResolverLoader, so\n * \t\t\t\t\t\tpass it to `super()` yourself when creating custom Resolvers\n * @param {...string} aliases Alternative names the Resolver can be identified by\n */\nexport class Resolver\n{\n\tprotected client: Client;\n\n\tpublic name: string;\n\tpublic aliases: string[];\n\n\tpublic constructor(client: Client, name: string, ...aliases: string[])\n\t{\n\t\tthis.client = client;\n\n\t\t/**\n\t\t * Name that servers as an identifier for the resolver\n\t\t * @type {string}\n\t\t */\n\t\tthis.name = name;\n\n\t\t/**\n\t\t * Additional identifier strings\n\t\t * @type {string[]}\n\t\t */\n\t\tthis.aliases = aliases;\n\t}\n\n\t/**\n\t * Method to implement that should return whether or not the\n\t * given value matches the type the resolver is meant to resolve.\n\t * >Can be async\n\t * @param {any} value Value to validate\n\t * @returns {Promise<boolean>}\n\t */\n\tpublic validate(value: any): any\n\t{\n\t\tthrow new Error('Resolvers must implement the `validate` method');\n\t}\n\n\t/**\n\t * Method to implement that should accept a string and return\n\t * a resolved value of the type the resolver is meant to resolve.\n\t *\n\t * This method can and should throw errors when invalid input is given.\n\t * These errors will be sent to Discord as argument errors when using\n\t * the `resolve` middleware. Refer to the base Resolver error strings\n\t * for examples on what these errors should look like if you're trying\n\t * to keep things in-line with YAMDBF\n\t *\n\t * >Can be async\n\t * @param {Message} message Discord.js Message instance\n\t * @param {Command} command Instance of the Command being called\n\t * @param {string} name Argument name\n\t * @param {string} value Argument value\n\t * @returns {Promise<any>}\n\t */\n\tpublic resolve(message: Message, command: Command, name: string, value: string): any\n\t{\n\t\tthrow new Error('Resolvers must implement the `resolve` method');\n\t}\n\n\t/**\n\t * Method recommended to be implemented for resolving data without side-effects.\n\t * Where `resolve()` should throw errors which will be sent to Discord when\n\t * a value cannot be resolved, this method should simply return `undefined`.\n\t *\n\t * All base resolvers will implement this method with this signature so that\n\t * they can be accessed for personal use via `<Client>.resolvers.get('resolver\n\t * name or alias')`.\n\t *\n\t * Some resolvers require additional context in the form of a partial {@link Message}\n\t * object in order to be able to resolve their data type from the given input\n\t * (like needing a guild from the message to be able to resolve a `GuildMember`\n\t * via the `Member` resolver). It's safest to assume that all base resolvers will\n\t * want this context reference as only a small handful do not (specifically String,\n\t * Number, Duration, Command, and CommandGroup). In the case of your own custom\n\t * resolvers, you should know what needs context and what doesn't, so you can get\n\t * away with passing as needed there.\n\t *\n\t * In cases where a full Message object is unavailable but context is known,\n\t * if you have a Guild instance, for example, you can simply pass it like\n\t * ```\n\t * let resolved = <Resolver>.resolveRaw(value, { guild });\n\t * ```\n\t * This is fine for all base resolvers, as the most any of them expect from\n\t * the context is for it to contain a `guild` field with a Guild instance,\n\t * and they will throw an error if the context they require is missing.\n\t *\n\t * >Can be async\n\t * @param {string} value String value to resolve data from\n\t * @param {Partial<Message>} [context] Partial Discord.js Message object\n\t * @returns {Promise<any>}\n\t */\n\tpublic resolveRaw(value: string, context?: Partial<Message>): any {}\n}\n"],"sourceRoot":"../../../src"}